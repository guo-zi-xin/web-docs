# TypeScript å¸¸ç”¨ç±»å‹å·¥å…·

### `Omit< T, K >`

`Omit< T, K >` ç”¨æ¥ä»å¯¹è±¡ç±»å‹ `T` ä¸­ï¼Œåˆ é™¤æŒ‡å®šå±æ€§ `K`, ç»„æˆä¸€ä¸ªæ–°çš„å¯¹è±¡è¿”å›

```typescript
  interface A {
  x: number;
  y: number;
  }

  type T1 = Omit<A, 'x'>;        // { y: number}

  type T2 = Omit<A, 'y'>;        // { x: number }

  type T3 = Omit<A, 'x' | 'y'>;  // { }

  type T4 = Omit<A, 'z'>;        // { x: number, y: number }
```

ä¸Šé¢çš„ç¤ºä¾‹ä¸­ `Omit< T, K >` ä»å¯¹è±¡ç±»å‹ `A`é‡Œåˆ é™¤æŒ‡å®šå±æ€§ï¼Œ è¿”å›å‰©ä¸‹çš„å±æ€§

æŒ‡å®šåˆ é™¤çš„é”®å`Keys`å¯ä»¥æ˜¯å¯¹è±¡ç±»å‹`Type`ä¸­ä¸å­˜åœ¨çš„å±æ€§ï¼Œä½†å¿…é¡»å…¼å®¹`string | number | symbol`

`Omit< T, K >` å®ç°å¦‚ä¸‹

```typescript
type Omit<T, k extends keyof any> = 
Pick<T, Exclude<keyof T, K>>
```

### `Pick< T, K >`

`Pick< T, K >`è¿”å›ä¸€ä¸ªæ–°çš„å¯¹è±¡ç±»å‹ï¼Œç¬¬ä¸€ä¸ªå‚æ•°`T`æ˜¯ä¸€ä¸ªå¯¹è±¡ç±»å‹ï¼Œç¬¬äºŒä¸ªå‚æ•°`K`æ˜¯`T`é‡Œé¢è¢«é€‰å®šçš„é”®åã€‚

```typescript
interface A {
  x: number;
  y: number;
}

type T1 = Pick<A, 'x'>;      // { x: number }

type T2 = Pick<A, 'y'>;      // { y: number }

type T3 = Pick<A, 'x' | 'y'> // { x: number, y: number }
```

ä¸Šé¢ç¤ºä¾‹ä¸­, `Pick< T, K >` ä¼šä»å¯¹è±¡ç±»å‹`A`ä¸­æŒ‘é€‰å‡ºæŒ‡å®šçš„é”®åï¼Œç»„æˆä¸€ä¸ªæ–°çš„å¯¹è±¡ç±»å‹ã€‚

æŒ‡å®šçš„é”®å`K`å¿…é¡»æ˜¯å¯¹è±¡é”®å`T`ä¸­å·²ç»å­˜åœ¨çš„é”®åï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼š

```typescript
interface A {
  x: number;
  y: number;
}

type T4 = Pick<A, 'z'>        //æŠ¥é”™
```

`Pick< T, K >`å®ç°å¦‚ä¸‹

```typescript
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

### `Partial< T >`

`Partial< T >`è¿”å›ä¸€ä¸ªæ–°ç±»å‹ï¼Œå°†å‚æ•°ç±»å‹ `T`çš„æ‰€æœ‰å±æ€§å˜ä¸ºå¯é€‰å±æ€§

```typescript
interface A {
  x: number;
  y: number
}

type T1 = Partial<A>; // { x?: number; y?: number }
```

`Partial< T >`å®ç°å¦‚ä¸‹

```typescript
type Partial<T> = {
  // éå†Tçš„å±æ€§å: å¯¹åº”çš„å±æ€§å€¼
  [P in keyof T]?: T[P]
}
```

### `Required< T >`

`Required<T>`è¿”å›ä¸€ä¸ªæ–°ç±»å‹ï¼Œå°†å‚æ•°ç±»å‹`T`çš„æ‰€æœ‰å±æ€§å˜ä¸ºå¿…é€‰å±æ€§ã€‚ å®ƒä¸`Partial`ä½œç”¨åˆšå¥½ç›¸åã€‚

```typescript
interface A {
  x?: number;
  y:number
}

type T1 = Required<A> // { x: number; y: number }
```

`Required< T >`çš„å®ç°å¦‚ä¸‹

```typescript
type Required<T> = {
  [P in keyof T]-?: T[P]
}
```

ä¸Šè¿°ä»£ç ä¸­, ç¬¦å·`-?`è¡¨ç¤ºå»é™¤å¯é€‰å±æ€§çš„"é—®å·"ï¼Œä½¿å…¶å˜ä¸ºå¿…é€‰å±æ€§ã€‚

ç›¸å¯¹åº”çš„ï¼Œç¬¦å·`+?`è¡¨ç¤ºå¢åŠ å¯é€‰å±æ€§çš„"é—®å·"ï¼Œç­‰åŒäº`?` å› æ­¤ï¼Œ å‰é¢çš„`Partial< T >`çš„å®šä¹‰ä¹Ÿå¯ä»¥å†™æˆä¸‹é¢è¿™æ ·ï¼š

```typescript
type Partial<T> = {
  [P in keyof T]+?: T[P]
}
```

### `Readonly< T >`

`Readonly< T >`è¿”å›ä¸€ä¸ªæ–°ç±»å‹ï¼Œ å°†å‚æ•°ç±»å‹`T`çš„æ‰€æœ‰å±æ€§å˜ä¸ºåªè¯»å±æ€§

```typescript
interface A {
  x: number;
  y?: number
}

type T1 = Readonly<A>  // { readonly x: number; readonly y?: number}
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œ `y`æ˜¯å¯é€‰å±æ€§ï¼Œ`Readonly< T >`ä¸ä¼šæ”¹å˜è¿™ä¸€ç‚¹ï¼Œ åªä¼šè®©`y`å˜ä¸ºåªè¯»

`Readonly`çš„å®ç°å¦‚ä¸‹

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}
```

:::info PS
æˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰ç±»å‹å·¥å…·`Mutable< T >`, å°†å‚æ•°ç±»å‹çš„æ‰€æœ‰å±æ€§å˜ä¸ºå¯å˜å±æ€§ã€‚

```typescript
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
}
```

ä¸Šé¢ä»£ç ä¸­ï¼Œ `-readonly`è¡¨ç¤ºå»é™¤å±æ€§çš„åªè¯»æ ‡å¿—ã€‚

ç›¸åº”åœ°, `+readonly`å°±è¡¨ç¤ºå¢åŠ åªè¯»æ ‡å¿—ï¼Œç­‰åŒäº`readonly`ã€‚å› æ­¤ï¼Œ`Readonly< T >`çš„å®ç°ä¹Ÿå¯ä»¥å†™æˆä¸‹é¢è¿™æ ·:

```typescript
type Readonly<T> = {
  +readonly [P in keyof T]: T[P];
}
```

:::

> `Readonly< T >`å¯ä»¥ä¸`Partial< T >`ç»“åˆä½¿ç”¨ï¼Œå°†æ‰€æœ‰å±æ€§å˜æˆåªè¯»çš„å¯é€‰å±æ€§

```typescript
interface Person {
  name: string;
  age: number;
}

const worker:Readonly<Partial<Person>> = { name: 'å¼ ä¸‰' }

worker.name = 'æå››' // æŠ¥é”™
```

### `Record< T, K >`

`Record<T, K>`è¿”å›ä¸€ä¸ªå¯¹è±¡ç±»å‹ï¼Œå‚æ•°`K`ä½œä¸ºé”®åï¼Œå‚æ•°`T`ä½œä¸ºé”®å€¼ç±»å‹ã€‚

```typescript
type T = Record<'a', number>   // { a: number }
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œ`Record< T, K >`çš„ç¬¬ä¸€ä¸ªå‚æ•° 'a' ç”¨ä½œå¯¹è±¡çš„é”®åï¼Œç¬¬äºŒä¸ªå‚æ•°'number' æ˜¯ 'a'çš„é”®å€¼ç±»å‹ã€‚

å‚æ•°`K`å¯ä»¥æ˜¯è”åˆç±»å‹ï¼Œè¿™æ—¶ä¼šä¾æ¬¡å±•å¼€ä¸ºå¤šä¸ªé”®ã€‚

```typescript
type T = Record<'a' | 'b', number> // { a: number, b: number}
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è”åˆç±»å‹`'a' | 'b'`ï¼Œå±•å¼€æˆä¸¤ä¸ªé”®å`a`å’Œ`b`ã€‚

å¦‚æœå‚æ•°`T`æ˜¯è”åˆç±»å‹ï¼Œè¡¨æ˜é”®å€¼æ˜¯è”åˆç±»å‹

```typescript
type T = Record<'a', number | string>
```

å‚æ•°`K`çš„ç±»å‹å¿…é¡»å…¼å®¹`string | number |symbol`ç±»å‹ï¼Œå¦åˆ™ä¸èƒ½ç”¨ä½œé”®åï¼Œ ä¼šæŠ¥é”™ã€‚

`Record< K,T >`çš„å®ç°å¦‚ä¸‹ï¼š

```typescript
type Record<K extends string | number | symbol, T> = {
  [P in K]: T
}
```

### `Exclude< T, U >`

`Exclude< T, U >`ç”¨æ¥ä»è”åˆç±»å‹`T`é‡Œé¢ï¼Œåˆ é™¤æŸäº›ç±»å‹`U`ï¼Œç»„æˆä¸€ä¸ªæ–°çš„ç±»å‹è¿”å›ã€‚

```typescript
type T1 = Exclude<'a' | 'b' | 'c', 'a'>;            // 'b' | 'c'
type T2 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>;      // 'c'
type T3 = Exclude<string | (() => void), Function>; // string
type T4 = Exclude<string | string[], any[]>;        // string
type T5 = Exclude<(() => void)| null, Function>;    // null
type T6 = Exclude<200 | 400, 200 | 201>;            // 400
type T7 = Exclude<number, boolean>;                 // number
```

`Exclude< T, U >`çš„å®ç°å¦‚ä¸‹ï¼š

```typescript
type Exclude<T, U> = T extends U ? never : T
```

ä¸Šé¢ä»£ç ä¸­ï¼Œ ç­‰å·å³è¾¹çš„éƒ¨åˆ†ï¼Œè¡¨ç¤ºå…ˆåˆ¤æ–­`T`æ˜¯å¦å…¼å®¹`U`,å¦‚æœæ˜¯çš„è¯å°±è¿”å›`never`ç±»å‹ï¼Œå¦åˆ™å°±è¿”å›å½“å‰ç±»å‹`T`ã€‚

ç”±äº`never`ç±»å‹æ˜¯ä»»ä½•å…¶ä»–ç±»å‹çš„å­ç±»å‹ï¼Œå®ƒè·Ÿå…¶å®ƒç±»å‹ç»„æˆè”åˆç±»å‹æ—¶å€™ï¼Œå¯ä»¥ç›´æ¥å°†`never`ç±»å‹ä»è”åˆç±»å‹ä¸­'æ¶ˆæ‰'ï¼Œ å› æ­¤`Exclude< T, U >`ç›¸å½“äºåˆ é™¤å…¼å®¹çš„ç±»å‹ï¼Œ å‰©ä¸‹ä¸å…¼å®¹çš„ç±»å‹

### `Extract< T, U >`

`Extract< T, U >`ç”¨æ¥ä»è”åˆç±»å‹`T`ä¸­ï¼Œæå–æŒ‡å®šç±»å‹`U`,ç»„æˆä¸€ä¸ªæ–°ç±»å‹è¿”å›ã€‚å®ƒä¸`Exclude< T, U >`æ­£å¥½ç›¸åã€‚

```typescript
type T1 = Extract<'a' | 'b' | 'c', 'a'>;          // 'a'
type T2 = Extract<'a' | 'b' | 'c', 'a' | 'b'>;    // 'a' | 'b'
type T3 = Extract<'a' | 'b' | 'c', 'a' | 'd'>;    // 'a'
type T4 = Extract<string | string[], any[]>;      // string[]
type T5 = Extract<(() => void) | null, Function>; // () => void
type T6 = Extract<200 | 400, 200 | 201>;          // 200
```

å¦‚æœå‚æ•°`U`ä¸åŒ…å«åœ¨è”åˆç±»å‹`T`ä¸­ï¼Œ åˆ™è¿”å›neverç±»å‹

```typescript
type T = Extract<string | number, boolean>;    // never
```

`Extract< T, U >`å®ç°å¦‚ä¸‹ï¼š

```typescript
type Extract<T, U> = T extends U ? T : never
```

### `NonNullable< T >`

`NonNullable< T >`ç”¨æ¥ä»è”åˆç±»å‹`T`ä¸­åˆ é™¤`null`ç±»å‹å’Œ `undefined`ç±»å‹ï¼Œç»„æˆä¸€ä¸ªæ–°ç±»å‹è¿”å›ï¼Œä¹Ÿå°±æ˜¯è¿”å›`T`çš„éç©ºç±»å‹ç‰ˆæœ¬

```typescript
type T1 = NonNullable<string | number | undefined> // string | number
type T2 = NonNullable<string[] | null | undefined> // string[]
type T3 = NonNullable<boolean>  // boolean
type T4 = NonNullable<number | null> // number
type T5 = NonNullable<string | undefined> // string
type T6 = NonNullable<null | undefined> // never
```

`NonNullable< T >`çš„å®ç°å¦‚ä¸‹ï¼š

```typescript
type NonNullable<T> = T & {}
```

ä¸Šé¢ä»£ç ä¸­ï¼Œ `T & {}` ç­‰åŒäºæ±‚ `T & Object`çš„äº¤å‰ç±»å‹ã€‚ç”±äº Typescriptçš„éç©ºå€¼éƒ½æ˜¯`Object`çš„å­ç±»å‹ï¼Œæ‰€ä»¥ä¼šè¿”å›è‡ªèº«ï¼›è€Œ`null`å’Œ `undefined`ä¸å±äº`Object`ï¼Œ ä¼šè¿”å›`never`ç±»å‹ã€‚

### `ReturnType< T >`

`ReturnType< T >`æå–å‡½æ•°ç±»å‹`T`çš„è¿”å›å€¼ç±»å‹ï¼Œä½œä¸ºä¸€ä¸ªæ–°ç±»å‹è¿”å›

```typescript
type T1 = ReturnType<() => string>  // string
type T2 = ReturnType<() => { a: string; b: number}> // { a: string, y: number}
type T3 = ReturnType<(s:string) => void> // void
type T4 = ReturnType<() => () => any[]> // () => any[]
type T5 = ReturnType<typeof Math.random> // number
type T6 = ReturnType<typeof Array.isArray> //boolean
```

å¦‚æœå‚æ•°ç±»å‹æ˜¯æ³›å‹å‚æ•°ï¼Œè¿”å›å€¼å–å†³äºæ³›å‹ç±»å‹ã€‚å¦‚æœæ³›å‹ä¸å¸¦æœ‰é™åˆ¶æ¡ä»¶ï¼Œå°±ä¼šè¿”å›`unknown`

```typescript
type T7 = ReturnType<<T>() => T> // unknown
type T8 = ReturnType<<T extends U, U extends number[]>() => T> // number[]
```

å¦‚æœç±»å‹ä¸æ˜¯å‡½æ•°ï¼Œä¼šæŠ¥é”™

```typescript
type T9 = ReturnType<boolean> //æŠ¥é”™
type T0 = ReturnType<Function> //æŠ¥é”™
```

`any`å’Œ`never`æ˜¯ä¸¤ä¸ªç‰¹æ®Šå€¼ï¼Œåˆ†åˆ«è¿”å›`any`å’Œ `never`

```typescript
type T1 = ReturnType<any>; // any

type T2 = ReturnType<never>; // never
```

`ReturnType< T >`çš„å®ç°å¦‚ä¸‹ï¼š

```typescript
type ReturnType<T extends (...args: any) => any> = T extends (...args:any) => infer R ? R : any
```

### `Parameters< T >`

`Parameters< T >`ä»å‡½æ•°ç±»å‹é‡Œé¢æå–å‚æ•°ç±»å‹ï¼Œç»„æˆä¸€ä¸ªå…ƒç»„è¿”å›

```typescript
type T1 = Parameters<() => string>  // []
type T2 = Parameters<(s: string) => void>; // [s: string]
type T3 = Parameters<<T>(arg:T) => T> //[arg:unknown]
type T4 = Parameters<(x : {a: number; b: string}) => void> // [x: { a: number, b:number }]
```

> ä¸Šé¢å®ä¾‹ä¸­ï¼Œ`Parameters< T >`çš„è¿”å›å€¼ä¼šåŒ…æ‹¬å‡½æ•°çš„å‚æ•°åï¼Œè¿™ä¸€ç‚¹éœ€è¦æ³¨æ„ã€‚

å¦‚æœå‚æ•°ç±»å‹`T`ä¸æ˜¯å¸¦æœ‰å‚æ•°çš„å‡½æ•°å½¢å¼ï¼Œ ä¼šæŠ¥é”™

```typescript
type T5 = Parameters<string> // æŠ¥é”™
type T6 = Parameters<Function> //æŠ¥é”™
```

`any`å’Œ`never`æ˜¯ä¸¤ä¸ªç‰¹æ®Šå€¼ï¼Œåˆ†åˆ«è¿”å›`unknown[]`å’Œ `never`

```typescript
type T7 = Parameters<any>; // unknown[]

type T8 = Parameters<never>; // never
```

:::info å¼•ç”³
`Parameters< T >`ä¸»è¦ç”¨äºä»å¤–éƒ¨æ¨¡å—æä¾›çš„å‡½æ•°ç±»å‹ä¸­ï¼Œè·å–å‚æ•°ç±»å‹ã€‚

```typescript
interface IRequest {
  first: string;
  last: string
}

interface IReponse {
  name: IRequest;
  gift: string
}

export function getGift(name: IRequest, gift: string): IReponse {
  // ...
}
```

ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œæ¨¡å—åªè¾“å‡ºäº†å‡½æ•°`getGift()`, æ²¡æœ‰è¾“å‡ºå‚æ•°`IRequest`å’Œè¿”å›å€¼`IReponse`ã€‚

è¿™æ—¶å°±å¯ä»¥é€šè¿‡`Parameters< T >`å’Œ `ReturnType< T >` æ‹¿åˆ°è¿™ä¸¤ä¸ªæ¥å£ç±»å‹

```typescript
type ParaT = Parameters<typeof getGift>[0] // IRequest
type ReturnT = ReturnType<typeof getGift> // IResponse
```

:::

`Parameters< T >`å®ç°å¦‚ä¸‹ï¼š

```typescript
type Parameters<T extends (...args:any) => any> = T extends (...args: infer P) => any ? P : never
```

### `ConstructorParameters< T >`

`ConstructorParameters< T >`æå–æ„é€ æ–¹æ³•`T`çš„å‚æ•°ç±»å‹ï¼Œç»„æˆä¸€ä¸ªå…ƒç¥–ç±»å‹è¿”å›

```typescript
type T1 = ConstructorParameters<new (x: string, y: number) => object> // [x: string, y:number]

type T2 = ConstructorParameters<new (x?: string) => object> // [x?: string | undefined]
```

å®ƒå¯ä»¥è¿”å›ä¸€äº›å†…ç½®æ„é€ æ–¹æ³•çš„å‚æ•°ç±»å‹

```typescript
type T3 = ConstructorParameters<ErrorConstructor> // [message?: string]

type T4 = COnstructorParameter<FunctionConstructor> // string[]

type T5 = ConstructorParameter<RegExpConstructor> //[pattern:string | RegExp, flags?: string]
```

å¦‚æœå‚æ•°ç±»å‹ä¸æ˜¯æ„é€ æ–¹æ³•ï¼Œå°±ä¼šæŠ¥é”™

```typescript
type T6 = ConstructorParameters<string> //æŠ¥é”™
type T7 = ConstructorParameters<Function> //æŠ¥é”™
```

`any`å’Œ`never`æ˜¯ä¸¤ä¸ªç‰¹æ®Šå€¼ï¼Œåˆ†åˆ«è¿”å›`unknown[]`å’Œ `never`

```typescript
type T7 = ConstructorParameters<any>; // unknown[]

type T8 = ConstructorParameters<never>; // never
```

`ConstructorParameters< T >`å®ç°å¦‚ä¸‹ï¼š

```typescript
type ConstructorParameters<T extends abstract new (...args: any) => any> = 
T extends abstract new (...args: infer P) => any ? P : never
```

### `ThisParameterType< T >`

`ThisParameterType< T >`æå–å‡½æ•°ç±»å‹ä¸­çš„`this`å‚æ•°çš„ç±»å‹

```typescript
function toHex(this: number) {
  return this.toString(16)
}

type T = ThisParameterType<typeof toHex> // number
```

å¦‚æœå‡½æ•°æ²¡æœ‰ `this`å‚æ•°ï¼Œ åˆ™è¿”å›`unknown`

`ThisParameterType< T >`å®ç°å¦‚ä¸‹

```typescript
type ThisParameterType<T> = T extends (this: infer U, ...args: never) => any ? U : unknown
```

### `InstanceType< T >`

`InstanceType< T >`æå–æ„é€ å‡½æ•°çš„è¿”å›å€¼çš„ç±»å‹ï¼ˆå³å®ä¾‹ç±»å‹ï¼‰ï¼Œå‚æ•°`T`æ˜¯ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œç­‰åŒäºæ„é€ å‡½æ•°çš„`ReturnType< T >`ã€‚

```typescript
type T = InstanceType<new () => object> // object
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œç±»å‹å‚æ•°æ˜¯ä¸€ä¸ªæ„é€ å‡½æ•°`new () => object`, è¿”å›å€¼æ˜¯è¯¥æ„é€ å‡½æ•°çš„å®ä¾‹ç±»å‹(`object`)ã€‚

ç¤ºä¾‹ï¼š

```typescript
type A = InstanceType<ErrorConstructor> // Error
type B = InstanceType<FunctionCOnstructor> // Function
type C = InstanceType<RegExpConstructor> // RegExp
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œ `InstanceType< T >`çš„å‚æ•°éƒ½æ˜¯Typescriptå†…ç½®çš„åŸç”Ÿå¯¹è±¡çš„æ„é€ å‡½æ•°ç±»å‹ï¼Œæ‰€ä»¥è¿”å›å€¼å°±æ˜¯è¿™äº›æ„é€ å‡½æ•°çš„å®ä¾‹ç±»å‹ã€‚

ç”±äº Classä½œä¸ºç±»å‹ï¼Œ ä»£è¡¨å®ä¾‹ç±»å‹ï¼Œ è¦è·å–å®ƒçš„æ„é€ æ–¹æ³•ï¼Œå¿…é¡»æŠŠå®ƒå½“æˆå€¼ï¼Œç„¶åç”¨`typeof`è¿ç®—ç¬¦è·å–å®ƒçš„æ„é€ æ–¹æ³•ç±»å‹

```typescript
class D {
  x = 0;
  y = 0
}

type T = InstanceType<typeof D> // D
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œ`typeof C`æ˜¯`C`çš„æ„é€ æ–¹æ³•ç±»å‹ï¼Œç„¶å InstanceType å°±èƒ½è·å¾—å®ä¾‹ç±»å‹ï¼Œå³`C`æœ¬èº«ã€‚

å¦‚æœç±»å‹å‚æ•°ä¸æ˜¯æ„é€ æ–¹æ³•ï¼Œå°±ä¼šæŠ¥é”™

```typescript
type T1 = InstanceType<string>; // æŠ¥é”™

type T2 = InstanceType<Function>; // æŠ¥é”™
```

å¦‚æœç±»å‹å‚æ•°æ˜¯`any`æˆ–`never`ä¸¤ä¸ªç‰¹æ®Šå€¼ï¼Œåˆ†åˆ«è¿”å›`any`å’Œ`never`ã€‚

```typescript
type T3 = InstanceType<any>; // any

type T4 = InstanceType<never>; // never
```

`InstanceType< T >`çš„å®ç°å¦‚ä¸‹:

```typescript
type InstanceType<T extends abstract new (...args: any) => any> = 
T extends abstract new (...args: any) => infer R ? R : any
```

### `Awaited< T >`

`Awaited< T >`ç”¨æ¥å–å‡º Promise çš„è¿”å›å€¼ç±»å‹ï¼Œé€‚åˆç”¨åœ¨æè¿°`then()`æ–¹æ³•å’Œ`await`å‘½ä»¤çš„å‚æ•°ç±»å‹ã€‚

```typescript
type A  = Awaited<Promise<string>> // string
```

å®ƒä¹Ÿå¯ä»¥è¿”å›å¤šé‡ Promise çš„è¿”å›å€¼ç±»å‹ã€‚

```typescript
type B = Awaited<Promise<Promise<number>>>; // number
```

å¦‚æœå®ƒçš„ç±»å‹å‚æ•°ä¸æ˜¯ Promise ç±»å‹ï¼Œé‚£ä¹ˆå°±ä¼šåŸæ ·è¿”å›ã€‚

```typescript
type C = Awaited<boolean | Promise<number>>; // number | boolean
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œç±»å‹å‚æ•°æ˜¯ä¸€ä¸ªè”åˆç±»å‹ï¼Œå…¶ä¸­çš„`boolean`ä¼šåŸæ ·è¿”å›ï¼Œæ‰€ä»¥æœ€ç»ˆè¿”å›çš„æ˜¯`number|boolean`ã€‚

`Awaited< T >`å®ç°å¦‚ä¸‹

```typescript
type Awaited<T> = 
T extends null | undefined ? T : 
  T extends object & 
    {
      then(onfulfilled: infer F, ...args: infer _): any
    } ? F extends (value: infer V, ...args: infer _) => any ? 
        Awaited<...> : never : 
    T
```

### `OmitThisParameter< T >`

`OmitThisParameter< T >`ä»å‡½æ•°ç±»å‹ä¸­ç§»é™¤`this`å‚æ•°ã€‚

```typescript
function toHex(this:number) {
  return this.toString(16)
}

type T = OmitThisParameter<typeof toHex> // () => string
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œ`OmitThisParameter< T >`ç»™å‡ºäº†å‡½æ•°`toHex()`çš„ç±»å‹ï¼Œå¹¶å°†å…¶ä¸­çš„`this`å‚æ•°åˆ é™¤ã€‚

å¦‚æœå‡½æ•°æ²¡æœ‰ this å‚æ•°ï¼Œåˆ™è¿”å›åŸå§‹å‡½æ•°ç±»å‹ã€‚

`OmitThisParameter< T >`å®ç°å¦‚ä¸‹:

```typescript
type OmitThisParameter<T> = unknown extends ThisParameterType<T> ? 
  T : T extends (...args: infer A) => infer R ? (...args: A) => R : T
```

### `ThisType< T >`

`ThisType< T >`ä¸è¿”å›ç±»å‹ï¼Œ åªç”¨æ¥è·Ÿå…¶ä»–ç±»å‹ç»„æˆäº¤å‰ç±»å‹ï¼Œç”¨æ¥æç¤ºTypescriptå…¶ä»–ç±»å‹çš„`this`çš„ç±»å‹

```typescript
interface HelperThisValue {
  logError: (error: string) => void
}

let helperFunctions: 
{ [name: string]: Function } & ThisType<HelperThisValue> = 
{
  hello: function() {
    this.logError('Error: Something Wrong') //æ­£ç¡®
    this.update() // æŠ¥é”™
  }
}
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œå˜é‡`helperFunctions`çš„ç±»å‹æ˜¯ä¸€ä¸ªæ­£å¸¸çš„å¯¹è±¡ç±»å‹ä¸`ThisType< HelperThisValue >`ç»„æˆçš„äº¤å‰ç±»å‹ã€‚

è¿™é‡Œçš„`ThisType`çš„ä½œç”¨æ˜¯æç¤º TypeScriptï¼Œå˜é‡`helperFunctions`çš„`this`åº”è¯¥æ»¡è¶³`HelperThisValue`çš„æ¡ä»¶ã€‚æ‰€ä»¥ï¼Œ`this.logError()`å¯ä»¥æ­£ç¡®è°ƒç”¨ï¼Œè€Œ`this.update()`ä¼šæŠ¥é”™ï¼Œå› ä¸º`HelperThisValue`é‡Œé¢æ²¡æœ‰è¿™ä¸ªæ–¹æ³•ã€‚

::: warning æ³¨æ„ğŸ“Œ
æ³¨æ„ï¼Œä½¿ç”¨è¿™ä¸ªç±»å‹å·¥å…·æ—¶ï¼Œå¿…é¡»æ‰“å¼€noImplicitThisè®¾ç½®ã€‚
:::

ä¸‹é¢æ˜¯å¦ä¸€ä¸ªä¾‹å­:

```typescript
let obj: ThisType<{ x: number }> &
  { getX: () => number };

obj = {
  getX() {
    return this.x + this.y; // æŠ¥é”™
  },
};
```

ä¸Šé¢ç¤ºä¾‹ä¸­ï¼Œ`getX()`é‡Œé¢çš„`this.y`ä¼šæŠ¥é”™ï¼Œå› ä¸ºæ ¹æ®`ThisType< { x: number } >`ï¼Œè¿™ä¸ªå¯¹è±¡çš„`this`ä¸åŒ…å«å±æ€§`y`ã€‚

`ThisType< T >`çš„å®ç°å°±æ˜¯ä¸€ä¸ªç©ºæ¥å£

```typescript
interface ThisType<T> { }
```
