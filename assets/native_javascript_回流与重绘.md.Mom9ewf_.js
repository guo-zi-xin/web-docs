import{_ as e,o,c as d,R as c}from"./chunks/framework.AonOEUEq.js";const f=JSON.parse('{"title":"回流与重绘","description":"","frontmatter":{},"headers":[],"relativePath":"native/javascript/回流与重绘.md","filePath":"native/javascript/回流与重绘.md","lastUpdated":1700734386000}'),r={name:"native/javascript/回流与重绘.md"},t=c('<h1 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-label="Permalink to &quot;回流与重绘&quot;">​</a></h1><h3 id="回流-reflow" tabindex="-1"><code>回流（reflow）</code> <a class="header-anchor" href="#回流-reflow" aria-label="Permalink to &quot;`回流（reflow）`&quot;">​</a></h3><p><code>回流（reflow）</code>: <strong>当render树（渲染树）中的一部分或者全部因为大小边距等引起结构变化 而需要重建的过程叫做回流</strong></p><h3 id="重绘-repaint" tabindex="-1"><code>重绘（repaint）</code> <a class="header-anchor" href="#重绘-repaint" aria-label="Permalink to &quot;`重绘（repaint）`&quot;">​</a></h3><p><code>重绘（repaint）</code>:<strong>当render 树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘</strong></p><ul><li><strong>每个页面至少需要一次<code>回流</code>，就是在页面第一次加载的时候。在<code>回流</code>的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成<code>回流</code>后，浏览器会<em>重新绘制</em> 受影响的部分到屏幕中，该过程称为<code>重绘</code></strong></li></ul><hr><blockquote><p>注意：<strong><code>回流</code>一定会引起<code>重绘</code>， <code>重绘</code>不一定会引起<code>回流</code>；而且每个页面都至少需要一次<code>回流</code>，就是页面第一次开始加载的时候。</strong></p></blockquote><p>可能会有人问， 什么是 <strong><code>render树</code></strong>？在了解 <code>render树</code> 之前 我们先了解一下浏览器在页面加载完成后到页面显示的中间过程：</p><ul><li><p>首先将得到的代码解析生成<code>dom树</code>，这个dom树里边包括了所有的HTML的标签 包括<code>display：none</code> 还有js动态添加的元素等；</p></li><li><p>浏览器把所有的样式解析成样式结构体；</p></li><li><p>在dom树和样式结构体组合后构建成<code>render树</code> （不包括<code>display：none</code>，<code>head</code>节点，因为这些节点不会用于呈现，而且不会影响呈现 所以不再<code>render树</code>中； 但会包括<code>visibility：hidden</code>的节点）；</p></li><li><p>一旦<code>render树</code>构建完毕后，浏览器就可以根据<code>render树</code>来绘制页面了。</p></li></ul><img src="https://any-cross-1252921383.cos.ap-hongkong.myqcloud.com/test-image/reflux-%20redraw.jpg" alt="rander流程"><h3 id="render树" tabindex="-1">render树 <a class="header-anchor" href="#render树" aria-label="Permalink to &quot;render树&quot;">​</a></h3><p><code>render树</code>的节点叫做<strong>渲染器</strong>； 渲染器在<strong>文档解析</strong>和<code>dom树</code>创建之后创建，会计算dom节点的样式信息； 如果说元素设置成了<code>display：none</code>或者元素的子孙元素继承了<code>display：none</code>的属性，那么元素的<code>render树</code>则不会被创建， 节点的子类<code>display</code>属性决定该节点创建怎样的渲染器。</p><blockquote><p><strong>引起回流和重绘的原因是页面布局和几何属性发生了改变</strong></p></blockquote><h3 id="何时触发回流和重绘" tabindex="-1">何时触发回流和重绘 <a class="header-anchor" href="#何时触发回流和重绘" aria-label="Permalink to &quot;何时触发回流和重绘&quot;">​</a></h3><ul><li><p><strong>repaint重绘：</strong></p><ul><li><code>回流(reflow)</code>必定引起<code>重绘(repaint)</code>，重绘可以单独触发</li><li><strong>背景色</strong>、<strong>颜色</strong>、<strong>字体改变</strong>（注意：<strong>字体大小</strong>发生变化时，会触发<code>回流</code>）</li></ul></li><li><p><strong>reflow回流</strong>：</p><ul><li>页面第一次渲染（初始化）</li><li><code>DOM树</code>变化（如：增删节点）</li><li><code>render树</code>变化（如：<code>padding</code>改变）</li><li>浏览器窗口<code>resize</code></li><li>当你查询布局信息，包括<code>offsetLeft</code>、<code>offsetTop</code>、<code>offsetWidth</code>、<code>offsetHeight</code>、 <code>scrollTop</code>/<code>Left</code>/<code>Width</code>/<code>Height</code>、<code>clientTop</code>/<code>Left</code>/<code>Width</code>/<code>Height</code>、调用了<code>getComputedStyle()</code>或者<strong>IE</strong>的<code>currentStyle</code>时，浏览器为了返回最新值，会触发<code>回流</code>。</li></ul></li></ul><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><ul><li>尽量避免改变布局属性。如<code>width</code>, <code>height</code>, <code>left</code>, <code>top</code>。</li><li>除了<code>transforms</code>或者<code>opacity</code>属性都会引起重绘，做动画的时候要注意，尽量使用这两个属性；</li><li>使用<code>Flexbox</code>。</li><li>避免多次读取部分布局属性（同上）</li><li>将复杂的节点元素脱离文档流，降低回流成本</li></ul><h3 id="css" tabindex="-1">css <a class="header-anchor" href="#css" aria-label="Permalink to &quot;css&quot;">​</a></h3><ul><li>减少选择器的复杂性。</li><li>避免逐个修改节点样式，尽量一次性修改，减少style修改所影响元素的数量,使用cssText来替代要多次修改的style属性.</li></ul><h3 id="js" tabindex="-1">js <a class="header-anchor" href="#js" aria-label="Permalink to &quot;js&quot;">​</a></h3><p>我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>',22),a=[t];function l(i,n,s,p,h,u){return o(),d("div",null,a)}const _=e(r,[["render",l]]);export{f as __pageData,_ as default};
