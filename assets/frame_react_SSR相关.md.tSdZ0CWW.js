import{_ as a,o as e,c as t,a8 as r}from"./chunks/framework.QttzOlP4.js";const m=JSON.parse('{"title":"SSR相关","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/SSR相关.md","filePath":"frame/react/SSR相关.md","lastUpdated":1708859917000}'),o={name:"frame/react/SSR相关.md"},s=r('<h1 id="ssr相关" tabindex="-1">SSR相关 <a class="header-anchor" href="#ssr相关" aria-label="Permalink to &quot;SSR相关&quot;">​</a></h1><h3 id="对于ssr的理解" tabindex="-1">对于SSR的理解 <a class="header-anchor" href="#对于ssr的理解" aria-label="Permalink to &quot;对于SSR的理解&quot;">​</a></h3><ul><li><p><strong>对SEO友好</strong></p><p>爬虫获取到的是已经异步执行完成后得到的有数据的HTML</p></li><li><p><strong>所有模板、图片资源都存储在服务器端</strong></p></li><li><p><strong>一个HTML 返回所有数据</strong></p></li><li><p><strong>减少HTTP请求</strong></p></li><li><p><strong>响应快、用户体验好、首屏渲染快</strong></p><p>首屏渲染是Node发送过来的字符串， 并不依赖与js文件了， 这就会使用户更快地看到页面的内容。 尤其是针对大型单页应用， 打包后文件体积比较大， 普通客户端渲染加载所有所需文件的时间较长， 首页就会有一个很长的加载时间。</p></li></ul><h3 id="ssr的局限" tabindex="-1">SSR的局限 <a class="header-anchor" href="#ssr的局限" aria-label="Permalink to &quot;SSR的局限&quot;">​</a></h3><ol><li>服务端压力大: 正常是通过客户端去渲染、现在统一到服务端Node去做。 尤其是遇到高并发访问的情况， 会大量占用服务端CPU资源</li><li>开发条件受限: 在服务端渲染中只会执行到<code>componentDidMount</code>之前的生命周期， 因此有些第三方库会受到影响。</li></ol>',5),i=[s];function l(n,c,d,_,S,p){return e(),t("div",null,i)}const f=a(o,[["render",l]]);export{m as __pageData,f as default};
