import{_ as s,o as a,c as n,a8 as e}from"./chunks/framework.QttzOlP4.js";const h=JSON.parse('{"title":"React一些相关","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/react常用特性.md","filePath":"frame/react/react常用特性.md","lastUpdated":1711286453000}'),l={name:"frame/react/react常用特性.md"},o=e(`<h1 id="react一些相关" tabindex="-1">React一些相关 <a class="header-anchor" href="#react一些相关" aria-label="Permalink to &quot;React一些相关&quot;">​</a></h1><h3 id="react-和-vue的区别" tabindex="-1">React 和 Vue的区别 <a class="header-anchor" href="#react-和-vue的区别" aria-label="Permalink to &quot;React 和 Vue的区别&quot;">​</a></h3><ol><li>vue是双向绑定， react是单向数据流</li><li>在vue中我们组合不同功能的方式是通过Composition API、mixin、Provide/inject 而React中我们通过HOC(Higher Order Commponent) 高阶组件来执行</li><li>React是JSX渲染模板， Vue是通过拓展HTML语法进行渲染。</li></ol><h3 id="react-设计思想" tabindex="-1">React 设计思想 <a class="header-anchor" href="#react-设计思想" aria-label="Permalink to &quot;React 设计思想&quot;">​</a></h3><ul><li><strong>组件化</strong></li></ul><p>每个组件都符合开放 - 封闭原则， 封闭是针对渲染工作流来说，指的是组件内部的状态都由自身维护，只处理内部渲染逻辑； 开放是针对组件通信来说，指的是不同组件可以通过props(单向数据流)进行数据交互。</p><ul><li><strong>数据驱动视图</strong></li></ul><p>UI=(data) 渲染界面不应该直接操作dom， 而是通过修改数据 state 或 props， 数据驱动视图更新</p><ul><li><strong>虚拟DOM</strong></li></ul><p>由浏览器的渲染流水线可知 DOM 操作是一个非常昂贵的操作，很耗费性能， 所以就有了虚拟DOM， 虚拟DOM是对真实DOM的映射， React通过新旧DOM的对比得到需要更新的部分DOM， 实现数据的增量更新</p><h3 id="react生命周期" tabindex="-1">React生命周期 <a class="header-anchor" href="#react生命周期" aria-label="Permalink to &quot;React生命周期&quot;">​</a></h3><p>在16.8 hooks版本之前， React的生命周期分为组件挂载阶段、组件更新阶段、组件卸载阶段</p><ul><li>挂载</li></ul><p><code>constructor</code></p><p><code>componentWillMount</code>(React17版本中被移除)</p><p><code>render</code></p><p><code>componentDidMount</code></p><ul><li>更新</li></ul><p><code>componentWillReceiveProps</code> (React17版本中被移除)</p><p><code>shouldComponentUpdate</code></p><p><code>componentWillUpdate</code> (React17版本中被移除)</p><p><code>render</code></p><p><code>componentWillUnmount</code></p><ul><li>卸载</li></ul><p><code>componentWillUnmount</code></p><p>在16.8版本引入Hooks之后， 它提供了一种新的方式来使用状态和其他 React 特性而无需编写类组件。 Hooks并没有完全取代生命周期的方法， 但是可以在函数组件中完成类似的功能。 常用的hooks有： <code>useState</code>、<code>useEffect</code>、<code>useContext</code>等</p><h3 id="react-hooks与-react-class的区别" tabindex="-1">React Hooks与 React Class的区别 <a class="header-anchor" href="#react-hooks与-react-class的区别" aria-label="Permalink to &quot;React Hooks与 React Class的区别&quot;">​</a></h3><ol><li>Hooks更加简洁，并且更贴合原生js写法</li><li>业务代码更加聚合</li><li>逻辑代码方便复用</li></ol><h3 id="react的严格模式" tabindex="-1">React的严格模式 <a class="header-anchor" href="#react的严格模式" aria-label="Permalink to &quot;React的严格模式&quot;">​</a></h3><p>React的严格模式是在组件外层设置<code>React.scrictMode</code>标签，可以设置到根节点组件外层， 这样可以全局生效。</p><blockquote><p>React的严格模式检查仅在开发模式下运行， 它们并不会影响生产构建。</p></blockquote><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> React </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> ReactDOM </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">react-dom</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> App </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">./App</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#FFCB6B;">React.StriceMode</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">    &lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;">/&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;/</span><span style="color:#FFCB6B;">React.StriceMode</span><span style="color:#89DDFF;">&gt;,</span></span>
<span class="line"><span style="color:#BABED8;">   document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">root</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#BABED8;">)</span></span></code></pre></div><h5 id="严格模式优点" tabindex="-1">严格模式优点 <a class="header-anchor" href="#严格模式优点" aria-label="Permalink to &quot;严格模式优点&quot;">​</a></h5><ul><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li><li>未来的 React 版本将添加更多的额外功能</li></ul><h3 id="react-中页面重新加载怎么保留数据" tabindex="-1">React 中页面重新加载怎么保留数据 <a class="header-anchor" href="#react-中页面重新加载怎么保留数据" aria-label="Permalink to &quot;React 中页面重新加载怎么保留数据&quot;">​</a></h3><p>这个问题就涉及到了<strong>数据持久化</strong>， 主要有以下几种实现方式：</p><ul><li><p><strong>Redux</strong> 将页面数据储存在<em>Redux</em>中， 在页面重新加载时去获取Redux中的数据</p></li><li><p><strong>data.js</strong> 使用<em>webpack</em>构建的项目, 可以创建一个文件， data.js将数据保存在data中， 跳转页面后获取</p></li><li><p><strong>sessionStorage</strong> 存入<em>sessionStorage</em>初始化时查询， 有数据就加载， 无数据就是初始化状态</p></li><li><p><strong>History API</strong> 使用<code>pushState</code>函数可以支持临时储存</p></li><li><p><strong>zustand</strong> 轻量级状态管理包，不到1kb</p></li></ul><h3 id="jsx与js的区别" tabindex="-1">JSX与JS的区别 <a class="header-anchor" href="#jsx与js的区别" aria-label="Permalink to &quot;JSX与JS的区别&quot;">​</a></h3><p><em>JSX</em> 是React的语法糖，他允许在html中写js并且不能被浏览器识别， 需要通过webpack、babel之类的变异工具转换为js文件执行</p><p><em>JS</em>可以被打包工具直接编译不需要额外的转换， <em>JSX</em>需要<code>babel</code>编译转换为浏览器识别语言</p><p><em>JSX</em>是JS语法扩展允许在html中写js， js是原生写法需要通过script标签引入</p><h5 id="react中必须要使用-jsx吗" tabindex="-1">React中必须要使用 JSX吗？ <a class="header-anchor" href="#react中必须要使用-jsx吗" aria-label="Permalink to &quot;React中必须要使用 JSX吗？&quot;">​</a></h5><p>React中不强制使用<em>JSX</em>。 当不想在构建环境中配置有关<em>JSX</em>编译时候， 不在React中使用<em>JSX</em>会更加方便， 每个JSX元素只是调用 React.CreateElement(component, props, ...,children)的语法糖。 因此使用JSX可以完成的任何事情都可以通过原生JS来完成。</p><h3 id="react-处理错误边界-error-boundaries" tabindex="-1">React 处理错误边界(Error Boundaries) <a class="header-anchor" href="#react-处理错误边界-error-boundaries" aria-label="Permalink to &quot;React 处理错误边界(Error Boundaries)&quot;">​</a></h3><p>错误边界是一种React组件， 它能够不过并处理子组件中任何位置出现Javascript的错误，并渲染备用UI， 而不是使整个组件数崩溃。错误边界在生产环境中非常有用，可以防止程序因错误而崩溃，同事还可以帮助开发者定位到错误</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> React</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;"> {</span><span style="color:#BABED8;"> useState</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> useEffect</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;"> }</span><span style="color:#89DDFF;font-style:italic;"> from</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> ErrorBoundary </span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;"> ({</span><span style="color:#BABED8;font-style:italic;"> children</span><span style="color:#89DDFF;"> })</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#C792EA;">  const</span><span style="color:#89DDFF;"> [</span><span style="color:#BABED8;">hasError</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> setHasError</span><span style="color:#89DDFF;">]</span><span style="color:#89DDFF;"> =</span><span style="color:#82AAFF;"> useState</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">boolean</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">false</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">  useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#C792EA;">    const</span><span style="color:#BABED8;"> errorHandler</span><span style="color:#89DDFF;"> =</span><span style="color:#89DDFF;"> (</span><span style="color:#BABED8;font-style:italic;">error</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">      console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">error</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Error caught by ErrorBoundary</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> error</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#82AAFF;">      setHasError</span><span style="color:#F07178;">(</span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    // 捕获全局错误</span></span>
<span class="line"><span style="color:#BABED8;">    window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">error</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> errorHandler</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    return</span><span style="color:#89DDFF;"> ()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">      window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeEventListener</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">error</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> errorHandler</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    }</span></span>
<span class="line"><span style="color:#89DDFF;">  },</span><span style="color:#F07178;"> [])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">hasError</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    return</span><span style="color:#F07178;"> &lt;</span><span style="color:#FFCB6B;">h1</span><span style="color:#F07178;">&gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Something went wrong.</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#BABED8;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">  return</span><span style="color:#BABED8;"> children</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#89DDFF;font-style:italic;"> default</span><span style="color:#BABED8;"> ErrorBoundary</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h3 id="react-组件为什么要大写" tabindex="-1">React 组件为什么要大写 <a class="header-anchor" href="#react-组件为什么要大写" aria-label="Permalink to &quot;React 组件为什么要大写&quot;">​</a></h3><p>因为JSX语法无法被浏览器所识别， 需要使用Babel去转换为浏览器识别的js， 此时就会有个依据去判断是原生DOM标签还是React组件， 这个依据就是标签的首字母。</p><p>如果标签的首字母是小写就会被认为是原生标签， 反之就是React组件</p><h3 id="react-fragment" tabindex="-1">React.Fragment <a class="header-anchor" href="#react-fragment" aria-label="Permalink to &quot;React.Fragment&quot;">​</a></h3><p>React中组件是不允许返回多个节点的， 要想解决这个问题就需要套一层div标签， 但是这样会多增加一个节点， 所以在<code>16.0</code>版本之后， 官方推出了<strong>Fragment</strong>的概念， 能够让一个组件返回多个元素。</p><p>React.Fragment 等价于 一个空标签 <code>&lt; &gt;&lt;/ &gt;</code></p><blockquote><p><strong>两者的区别就是 React.Fragment可以使用key，但是空标签不可以</strong></p></blockquote><h3 id="受控组件、非受控组件" tabindex="-1">受控组件、非受控组件 <a class="header-anchor" href="#受控组件、非受控组件" aria-label="Permalink to &quot;受控组件、非受控组件&quot;">​</a></h3><ul><li><p>受控组件就是组组件的改变受控于数据的变化， 数据变了页面也就变了。 受控组件更合适，数据驱动是React的核心。</p><p>当需要在React组件中访问、修改或验证表单元素的值时， 应该使用受控组件。</p><p>适用于需要对表单元素的值进行实时操作和处理的情况。</p></li><li><p>非受控组件不是通过数据控制页面，而是直接通过DOM本身管理。</p><p>当需要快速地继承已有的HTML表单元素或访问DOM元素时， 可以考虑使用非受控组件。</p><p>适用于简单的表单场景或需要直接操作DOM元素的值得情况。</p></li></ul>`,55),t=[o];function p(r,c,i,D,F,y){return a(),n("div",null,t)}const u=s(l,[["render",p]]);export{h as __pageData,u as default};
