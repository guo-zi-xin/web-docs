import{_ as n}from"./chunks/CustomLink.HhFLulSs.js";import{_ as o,o as p,c as e,m as s,a as t,J as c,a8 as a,ao as r}from"./chunks/framework.QttzOlP4.js";const E=JSON.parse('{"title":"Vue 首页白屏问题以及解决方案","description":"","frontmatter":{},"headers":[],"relativePath":"frame/vue/首页白屏.md","filePath":"frame/vue/首页白屏.md","lastUpdated":1704194725000}'),i={name:"frame/vue/首页白屏.md"},F=a('<h1 id="vue-首页白屏问题以及解决方案" tabindex="-1">Vue 首页白屏问题以及解决方案 <a class="header-anchor" href="#vue-首页白屏问题以及解决方案" aria-label="Permalink to &quot;Vue 首页白屏问题以及解决方案&quot;">​</a></h1><h3 id="首页加载白屏的原因" tabindex="-1">首页加载白屏的原因 <a class="header-anchor" href="#首页加载白屏的原因" aria-label="Permalink to &quot;首页加载白屏的原因&quot;">​</a></h3><p>在谈论首页白屏问题之前，先了解一下<strong>SPA</strong></p><h4 id="spa" tabindex="-1">SPA <a class="header-anchor" href="#spa" aria-label="Permalink to &quot;SPA&quot;">​</a></h4><p>SPA(single-page application), 翻译过劳就是单页面应用。 <code>SPA</code>是一种网络应用程序或者网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之前切换打断用户体验， 在单页面应用中，所有有必要的代码(<code>HTML</code>、<code>Javascript</code> 和 <code>CSS</code>) 都通过单个页面的加载而检索，或者根据需要(通常是为响应用户操作)动态装在适当的资源并添加到页面， 页面在任何时间点 都不会重新加载，也不会将控制转移到其他页面。 举个例子： 一个杯子， 早上装的牛奶， 中午装的是开水， 晚上装的是茶， 我们发现，变得始终是杯子里的内容，而杯子始终是那个杯子：</p><img src="'+r+'" alt="SPA图示"><blockquote><p><code>React</code>、 <code>Vue</code> 都属于<code>SPA</code></p></blockquote><h5 id="spa-加载过程" tabindex="-1">SPA 加载过程 <a class="header-anchor" href="#spa-加载过程" aria-label="Permalink to &quot;SPA 加载过程&quot;">​</a></h5>',8),D=a(`<li><p>首先是 HTML 也就是 <code>FP</code>阶段</p><blockquote><p>FP(全称 First Paint， 翻译为 首次绘制) 是时间线上的第一个时间点，它代表浏览器第一次向屏幕传输像素的时间，也就是页面在屏幕上首次发生视觉变化的时间</p><p>注意： FP不包含默认背景绘制，但包含非默认的背景绘制</p></blockquote><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#C792EA;"> id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><blockquote><p>页面在导航后首次呈现出不同于导航前内容的时间点，有一个东西回来渲染在页面上了</p></blockquote></li><li><p>之后是静态资源 CSS、JS、 之后解析 JS， 生成 HTML， 也就是 <code>FCP</code> 阶段， CSS、JS 资源加载下来了，首次的内容绘制，有一个大结构了</p><blockquote><p>FCP(全称 First Contentful Paint， 翻译为 首次内容绘制) 顾名思义，它代表浏览器第一次向屏幕绘制 内容</p></blockquote><blockquote><p>注意： 只有首次绘制文本、图片(包含背景图)、 非白色的 <code>canvas</code> 或者 SVG 时才被算作 FCP</p></blockquote><details class="details custom-block"><summary>FP 和 FCP的区别</summary><p>FP 和 FCP这两个指标之间的主要区别是: FP是当浏览器开始绘制内容到屏幕上时，只要在视觉上发生变化，无论是什么内容触发的视觉变化，在这一刻，这个时间点，叫做FP</p><p>相比之下， FCP指的是浏览器首次绘制来自DOM的内容， 例如文本、图片、SVG、canvas元素等， 这个时间点叫FCP</p></details><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#C792EA;"> id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">div</span><span style="color:#C792EA;"> class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">header</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div></li>`,2),y=s("p",null,"最后是 FMP， ajax请求数据之后，首次有效绘制，就是页面加载差不多了，但是可能图片还没加载出来",-1),d=s("blockquote",null,[s("p",null,"FMP(全称 First Meaningful Paint, 翻译为 首次有效绘制) 表示页面的 '主要内容' 开始出现在屏幕上的时间点， 它是我们测量用户加载体验的主要指标")],-1),u=s("blockquote",null,[s("p",null,"FMP本质上是通过一个算法来猜测某个时间点可能是 FMP， 所以有时候不准")],-1),g=a(`<h4 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h4><ol><li><strong>预渲染</strong></li></ol><p>预渲染就是<code>webpack</code>打包的时候渲染,通过无头浏览器</p><blockquote><p>无头浏览器: 打包的时候，可以把index.html的内容放入浏览器，但是浏览器是空白的，然后当进入页面时直接加载这个index.html, 但没有ajax请求</p></blockquote><p>获取到预渲染的页面html内容，然后再放入index.html， 再到CDN, 直接请求html(相当于把FMP提前到了FP)，其实更像另外一种骨架屏， 少了ajax请求</p><p>但是由于我们这么做智能添加死数据，而不能把 ajax 请求的数据渲染到页面上，如何解决呢？</p><p>我们可以在app.vue中， 直接在script中给对应标签添加数据即可</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#BABED8;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#header</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">html</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">...</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span></code></pre></div><ol start="2"><li><strong>同构</strong></li></ol><p>同构渲染就是一套代码多端使用</p><p>现在有一些框架 Next、Nuxt 类似于渲染就是 vue -&gt; json -&gt; vue-server-render -&gt; html</p><ol start="3"><li><p><strong>SSR</strong></p><p>服务端渲染也可以解决首屏加载慢这个问题， 因为服务端会把所有数据全部渲染完成在返回给客户端</p><p>ssr =&gt; 请求 -&gt; node -&gt; 解析 -&gt; 返回给客户端(带请求数据)</p><p>但是需要解决 Node层的高并发问题</p></li><li><p><strong>路由懒加载</strong></p><p>可以通过 <code>plugin-syntax-dynamic-import</code> 插件</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#BABED8;"> Vue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">component</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">async-component</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,(</span><span style="color:#BABED8;font-style:italic;">resolve</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  import</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./AsyncComponent.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">   .</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">AsyncComponent</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#82AAFF;">    resolve</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">AsyncComponent</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">default</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">   }</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;"> }</span><span style="color:#BABED8;">)</span></span></code></pre></div></li><li><p><strong>quicklink</strong></p></li></ol><p>google 开源的一个脚本插件，可以置顶浏览器在空闲的时候去指定需要加载的数据</p><ol start="6"><li><p><strong>使用Gzip压缩，减少文件体积,加快首屏页面打开速度</strong></p><p><em><strong>服务器需要开启gzip</strong></em></p><p>我们可以通过使用webpack插件来实现这个功能</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;"> pnpm</span><span style="color:#C3E88D;"> install</span><span style="color:#C3E88D;"> vite-plugin-compression</span><span style="color:#C3E88D;"> --save-dev</span></span></code></pre></div></li></ol><p>vite.config.js中</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> ViteCompression </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#89DDFF;"> &#39;</span><span style="color:#C3E88D;">vite-plugin-compression</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#89DDFF;font-style:italic;"> default</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#F07178;">  plugins</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> [</span></span>
<span class="line"><span style="color:#82AAFF;">    ViteCompression</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">      // 配置选项，根据需要进行配置</span></span>
<span class="line"><span style="color:#89DDFF;">    }</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  ]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><ol start="7"><li><strong>外链CSS、JS文件</strong></li></ol><p>很多时候我们在main.js中直接import一些ui库或者css文件啥的，以后可以在index.html，通过script外链引入，这样就不会通过我们的webpack打包</p><ol start="8"><li><p><strong>loading</strong></p><p>首页加一个loading或许是最原始的方法了，在index.html里加一个loadingcss效果，当页面加载完成消失</p></li></ol>`,19);function m(h,_,A,C,v,P){const l=n;return p(),e("div",null,[F,s("ul",null,[D,s("li",null,[y,d,u,s("blockquote",null,[s("p",null,[t("FMP原理: "),c(l,{title:"捕获FMP的原理",href:"https://github.com/berwin/Blog/issues/42"})])])])]),g])}const S=o(i,[["render",m]]);export{E as __pageData,S as default};
